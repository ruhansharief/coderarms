{"/coderarms/blog/algorithms/gcd/":{"data":{"":"Go through the GCD alogirthm from brute force to the best optimized solution","1-improvisation---single-scan#1 Improvisation - Single Scan":" We are scanning 1 to m and 1 to n to find the common factors. Instead we can just scan from 1 to max(m,n) so that one scan (loop) would be sufficient. For each i in 1 to max(m,n) add i to fm if it divides m and add i to fn it divides n. We are computing two lists and then checking for the common numbers among them. Instead, we can create only one list which contains the numbers which divide both m and n. For each i in 1 to max(m,n) add the i to comm if it divides both m and n. Actually the common factor would be smaller or equal to the smaller number among m and n. Hence scannig the numbers from 1 to min(m,n) would suffice. def gcd(m,n): #Improvisation 1 comm = [] for i in range(1,min(m,n)+1): if m % i == 0 and n % i == 0: comm.append(i) return comm[-1] ","improvisation-2----no-lists#Improvisation 2  - No lists":" Its not required to store all the common factors in a list. Instead we can just store the common factor in a variable (rather than list). While scanning for the common factor, if we get one then the variable should be replaced with earlier factor. def gcd2(m,n): #Improvisation 2 for i in range(1,min(m,n)+1): if m % i == 0 and n % i == 0: mrcomm = i # We will not get the name error as there would be atleast one common factor that is 1. return mrcomm ","improvisation-3-scan-backwards#Improvisation 3: Scan Backwards":" In the above steps we are scanning from 1 and checking all the common factors. Since we want the greatest common factor, scanning from backwards would give us the result much faster in many cases. def gcd3_1(m,n): #Improvisation 3 for i in range(min(m,n),0,-1): if m % i == 0 and n % i == 0: return i def gcd3_2(m,n): #Improvisation 3 - while loop - using while loop is recommended #because in for loop the range gets all the values, in while that time can be reduced. i = min(m,n) while i\u003e0: if m % i == 0 and n % i == 0: return i else: i = i - 1 ","naive-method#Naive method":"Algorithm:\nFirst check for the factors of each number by looping the intergers from 1 to that number. Add the factors to a list Repeat the above two steps for both the numbers Then loop in thorugh the one of the list and sort out the common numbers in both. Since the common list will be in ascending order, return the last number which would be the gcd. The algorithm can be improved in many places. def factors(x): f = [] for i in range(1,x+1): if x%i == 0: f.append(i) return f def gcd(m,n): fm = factors(m) fn = factors(n) comm = [] for i in fm: if i in fn: comm.append(i) return comm[-1] print(gcd(14,63)) "},"title":"Greatest Common Divisor Alogrithm"},"/coderarms/blog/leetcode/1768/":{"data":{"":"","approach#\u003cstrong\u003eApproach\u003c/strong\u003e":"","code#\u003cstrong\u003eCode\u003c/strong\u003e":"Problem Statement Given two strings word1 and word2, merge them by taking characters alternately from each. Begin with the first character of word1, followed by the first character of word2, and so on. If one string is longer than the other, append the remaining characters of the longer string at the end.\nExample 1:\nInput: word1 = “abc”, word2 = “pqr” Output: “apbqcr”\nExplanation: The merged string will be merged as so:\nword1: a b c word2: p q r merged: a p b q c r Example 2:\nInput: word1 = “ab”, word2 = “pqrs” Output: “apbqrs”\nExplanation: Notice that as word2 is longer, “rs” is appended to the end.\nword1: a b word2: p q r s merged: a p b q r s Approach Things to consider:\nThis is an easy problem that can be solved efficiently using a two-pointer technique.\nSince Python strings are immutable, adding characters to a string in a loop (e.g., via +=) creates a new string each time, leading to poor performance. To avoid this, collect characters in a list and join them into a string at the end, which is more memory-efficient.\nThe goal is to achieve:\nTime complexity: O(n + m) Space complexity: O(n + m) Note\nwhere n is length of word1 and m is length of word2\nSteps:\nAssign two pointers, each one pointing to first character in each string. Lets take them as word1_pointer and word2_pointer and assing them to 0 (first character) Assign a empty list merged_list to save the characters alternatively. (Lists in python are like dynamic arrays) Run a loop n+m times because the final list will be of length n+m (length of both word1 and word2 added) Start with word1 and in each iteration, keep adding the character to which each pointer is pointing to the list. And then increment the pointers. Since the loop runs for the length n+m, we need some condition inside the loop for scenarios like n\u003em or n\u003cm and that condition would be to check the pointer is not crosing the length of the string. At the end of the loop, we will have a all the characters alternatively as items in merged_list. Join them together as as string and return it. Note\nThe list to string conversion is also of time complexity O(n) which doesn’t change the order of n.\nCode def mergeAlternately(word1: str, word2: str) -\u003e str: word1_pointer = 0 word2_pointer = 0 merged_list = [] for iteration in range(len(word1)+len(word2)): if word1_pointer \u003c len(word1): merged_list.append(word1[word1_pointer]) word1_pointer += 1 if word2_pointer \u003c len(word2): merged_list.append(word2[word2_pointer]) word2_pointer += 1 return \"\".join(merged_list) print(mergeAlternately(\"abc\",\"pqr\")) ","problem-statement#\u003cstrong\u003eProblem Statement\u003c/strong\u003e":""},"title":"Merge Strings Alternately"},"/coderarms/docs/":{"data":{"":"Explore the following sections to learn how to use Hextra:\nPython Fundamentals Data Structures "},"title":"Tutorials"},"/coderarms/docs/python/":{"data":{"":"This tutorials discusses about the primitive data types in python in perspective of memory consumption"},"title":"Python Fundamentals"},"/coderarms/docs/python/strings/":{"data":{"":"","#":" In all programming languages, including Python, the string data type represents a fundamental data type. In Python, a string is defined as a sequence of characters enclosed within single (’…’), double (\"…\"), or triple quotes (’’’…’’’ or “”\"…\"\"\"). This sequence can include alphabets, digits, symbols, or Unicode characters.\nMemory Allocation Basics Traditionally, each character was considered to occupy 1 byte of memory, with the total string size computed as the number of characters multiplied by one byte. For example, the string “hello” corresponds to the ASCII values [104, 101, 108, 108, 111] and is stored in five contiguous memory locations—i.e., five sequential bytes in memory.\nContiguous Memory in String Buffers Python strings allocate contiguous memory for their character buffers. This arrangement, managed via the PyUnicodeObject structure, contains metadata (length, encoding kind, hash) alongside a pointer to the underlying contiguous byte array, enabling efficient random access and slicing operations.\nNote\nHowever, in the newer versions of python (after 3.3), PEP 393 is introduced which does a smart way to handle the encoding to save memory. A detailed article will be made on this and linked here. Stay tuned for the updates. For now, we assume we are not dealing with the more special characters and hence consider ASCII encoding as the standard for this tutorial.\nImmutability The behaviour that once an object is created, cannot be changed or modified is called immutability. Strings are immutable in nature and hence once created can’t be modified.\nHow can we access the characters in a string? Accessing a string can be done in two ways:\nIndexing Slicing Indexing We can access characters of a string by using the indexes. There are two types of indexes - Positive and Negative.\n## synatax ## # char = s[i] s = \"hello world\" print(s[0]) # Output: 'h' print(s[-1]) # Output: 'd' Time Complexity - O(1): Since the string will be stored in contingious memoty locatuions, the time complexity of indexing is O(1) Space Complexity - O(1): No extra strings are created when accessing using the indexing and hence the space complexity is also O(1) Slicing Slicing is the operation of extracting a portion of a string using a range of indices. In Python, this is done using the syntax:\n## syntax ## #substring = original_string[start:end] s = \"hello world\" print(s[0:5]) # Output: 'hello' This creates a new string that includes characters from index start up to, but not including, end.\nTime Complexity - O(k): Because python has to copy each of the k characters from the original string to create a new string (k is the length of the resulting substring end - start) and takes linear time, the complexity is O(k).\nSpace Complexity - O(k): Because strings are immutable, a new string is always created during slicing. This new string takes up space proportional to k characters.\nAdditon Adding or concatenation of the strings creates a brand-new string that contains all characters from s1 followed by all characters from s2. Python must allocate new memory and copy over both strings.\ns1 = \"hello\" s2 = \"world\" s3 = s1 + s2 print(s3) # Output: 'helloworld' print(s1.concat(s2)) # Output: 'helloworld' Time Complexity - O(n + m): Because python has to copy the both the original strings to create a new string and takes linear time, the complexity is O(n + m) time.\nSpace Complexity - O(n + m): Because strings are immutable, a new string is always created with the combined content. This new string takes up space proportional to n + m characters.\nMultiplication This repeats the original string n times, resulting in a string of length n * len(s). Python performs the repetition by allocating enough memory and copying the string n times, leading to O(n * len(s)) time and space complexity.\ns = \"hello\" n = 3 s1 = s * n print(s1) # Output: 'hellohellohello' Time Complexity - O(n * len(s)): Python performs the repetition by allocating enough memory and copying the string n times, leading to O(n * len(s)) time complexity.\nSpace Complexity -O(n * len(s)): O(n + m) space complexity\nMembership Operators: In and not in The in and not in operators in Python are used to check for the existence of a substring within another string. These are membership operators and return boolean value as per the existence\n\"ell\" in \"hello\" # True \"x\" in \"hello\" # False \"ell\" not in \"hello\" # False \"x\" not in \"hello\" # True Time Complexity - O(n x m): The time complexitiy of the membership operators would be O(n x m), where n is the length of the string s and m is be the legnth of the substring sub. Python loops through every possible starting position in s where sub could fit. At each position, it checks character-by-character if sub matches the corresponding slice of s.\nEach time a comparision of length m is made which adds O(m) time complexity It is made for whole length of n of the string which adds O(n) time complexity Hence the overall time complexity is O(n x m) Space Complexity - O(1): The space complexity is O(1), because a new string is not created in these operations\nNote\nCPython uses fast substring search algorithms (e.g., Boyer-Moore or variations), so the average case is faster, often close to O(n + m), but the worst-case theoretical time is O(n × m).\nstrip(), lstrip(), rstrip() Operations These are whitespace-trimming operations that return a new string with characters removed from either or both ends.\nMethod Action s.strip() Removes leading and trailing whitespace (both ends) s.lstrip() Removes whitespace only from the left (start) s.rstrip() Removes whitespace only from the right (end) s = \" hello \" print(s.strip()) # 'hello' print(s.lstrip()) # 'hello ' print(s.rstrip()) # ' hello' s2 = \"**hello**\" print(s2.strip(\"*\")) # 'hello' Python will start from the beginning (or end) and skips over all removable characters. Then copies the remaining characters into a new string (due to immutability).\nTime Complexity - O(n): he maximum number of characters it may need to look at is the full length of the string. Hence the time complexity is O(n).\nSpace Complexity -O(n): O(n) space complexity because a new string will be created.\nfind() Operationn The find() method is used to locate the first occurrence of a substring within another string. It returns the index of the first matching element or -1 if not found.\n### syntax ### # s.find(sub[, start[, end]]) # # s = \"machine learning\" print(s.find(\"learn\")) # Output: 8 print(s.find(\"deep\")) # Output: -1 print(s.find(\"a\", 2, 10)) # Output: 6 Time Complexity - O(n x m): It works similarly to the in operator sliding a window of size len(sub) over the string. At each position, checks if the substring matches. Stops when the first match is found. Hence the time complexity is O(n x m) Space Complexity - O(1): the space complexity is O(1). index() is similar to find() except that it throws an exception in case the sub string is not found\nNote\nCPython uses fast substring search algorithms (e.g., Boyer-Moore or variations), so the average case is faster, often close to O(n + m), but the worst-case theoretical time is O(n × m).\nreplace() Operation The replace() method returns a new string where all (or a limited number of) occurrences of a specified substring are replaced with another substring. In case of zero occurences of the specified string, it returns the original string without creating a new one\n### syntax ### # s.replace(old, new[, count]) # s = \"data science is a science\" print(s.replace(\"science\", \"engineering\")) # Output: \"data engineering is a engineering\" print(s.replace(\"science\", \"engineering\", 1)) # Output: \"data engineering is a science\" Python scans the string from left to right.\nEach time it finds old, it replaces it with new.\nStops after count replacements if provided.\nConstructs a new string (because strings are immutable).\nTime Complexity - O(n): The time complexity is O(n).\nSpace Complexity - O(1): the space complexity is O(1).\nsplit() Operation The split() method divides a string into a list of substrings, using a delimiter (separator). It’s commonly used to tokenize a string.\n### syntax ### # s.split(sep=None, maxsplit=-1) s = \"Python is fun\" print(s.split()) # Output: ['Python', 'is', 'fun'] s = \"2025-07-09\" print(s.split(\"-\")) # Output: ['2025', '07', '09'] s = \"one,two,three,four\" print(s.split(\",\", 2)) # Output: ['one', 'two', 'three,four'] Python iterates over the string from left to right.\nAt each match of the delimiter, it extracts the current token and starts collecting the next one.\nOnce all matches are found or maxsplit is reached, the remaining part is returned as the final substring.\nTime Complexity - O(n): Each character is read once.\nSpace Complexity - O(1): A new list with up to k substrings is created (depending on number of splits).\njoin() Operation The join() method is used to concatenate (combine) elements of an iterable (like a list or tuple of strings) into a single string, with a separator (the string calling join()) inserted between each element.\n### syntax ### # separator.join(iterable) words = [\"Python\", \"is\", \"awesome\"] result = \" \".join(words) print(result) # Output: \"Python is awesome\" fields = [\"2025\", \"07\", \"09\"] result = \",\".join(fields) print(result) # Output: \"2025,07,09\" chars = [\"a\", \"b\", \"c\"] print(\"\".join(chars)) # Output: \"abc\" Python first calculates the total length of the final string in memory to optimize allocation.\nThen it iteratively copies each string from the iterable and inserts the separator between them.\nStrings are immutable, so a new string is created (efficiently, in one pass—not through repeated concatenation).\nTime Complexity - O(n): Python loops once over the iterable to compute the result.\nSpace Complexity - O(1): A new string is created with the combined content.\nTime and Space Complexity of Common String Operations Operation Time Complexity Space Complexity Description s[i] O(1) O(1) Retrieve character at index i s[start:end] O(k) O(k) Extract substring of length k; a new string is created s1 + s2 O(n + m) O(n + m) Concatenate strings of length n and m; new memory is allocated s * n O(n * len(s)) O(n * len(s)) Repeat string n times; creates a new string with repeated content len(s) O(1) O(1) Return number of characters 'sub' in s O(n * m) worst-case O(1) Substring search using pattern matching algorithms s1 == s2 O(k) O(1) Character-wise equality comparison s.strip() O(n) O(n) Trim leading/trailing whitespace s.replace(a, b) O(n) O(n) Replace all instances of a with b s.split(delim) O(n) O(k) Divide string into substrings at delimiter delim.join(list) O(n) O(n) Join list of strings with delimiter s.lower() O(n) O(n) Convert string to lowercase s.upper() O(n) O(n) Convert string to uppercase s.find(sub) O(n * m) worst-case O(1) Return index of first occurrence or -1 s.index(sub) O(n * m) worst-case O(1) Like find, but raises error if not found s.count(sub) O(n * m) worst-case O(1) Count occurrences of substring s.startswith(sub) O(k) O(1) Test if string begins with substring s.endswith(sub) O(k) O(1) Test if string ends with substring "},"title":"Strings"}}